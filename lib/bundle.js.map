{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/color_helper.js","webpack:///./lib/coord.js","webpack:///./lib/entry.js","webpack:///./lib/map.js","webpack:///./lib/map_view.js","webpack:///./lib/oscillator_sound.js","webpack:///./lib/path.js","webpack:///./lib/path_segment.js","webpack:///./lib/train.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACnEA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,wBAAwB;AACxB;AACA,uCAAuC,OAAO;AAC9C,GAAG;;AAEH;AACA,aAAa,OAAO;AACpB;;;;;;;;;;;;;ACpBA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;ACxDA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;;AAEtD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;ACxCD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;;;;;;;;;;;;;ACtMJ;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,yGAAyG,IAAI;AAC7G;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AClDA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACnEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;;AAER;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;ACnGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;AClJwB;;AAExB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,uDAAuD;AAClE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/assets/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/entry.js\");\n","// fn to programatically lighten or darken hex color;\nexport const shadeHexColor = (color, percent) => {\n  let R = parseInt(color.substring(1,3), 16);\n  let G = parseInt(color.substring(3,5), 16);\n  let B = parseInt(color.substring(5,7), 16);\n\n  R = parseInt( (R * (100 + percent)) / 100);\n  G = parseInt( (G * (100 + percent)) / 100);\n  B = parseInt( (B * (100 + percent)) / 100);\n\n  const hexComponents = [R, G, B]\n\n  const hexStr = hexComponents.map( hexComp => {\n    if (hexComp > 256) { return '00' }\n    const subStr = hexComp.toString(16);\n    return (subStr.length === 1) ? `0${subStr}` : subStr;\n  });\n\n  debugger;\n  return `#${hexStr}`;\n}\n","class Coord {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  equals(coord2) {\n    return (this.x == coord2.x) && (this.y == coord2.y);\n  }\n\n  plus(coord2) {\n    return new Coord(this.x + coord2.x, this.y + coord2.y);\n  }\n\n  distBetween(coord2) {\n    return Math.sqrt(\n      Math.pow(this.x - coord2.x, 2) + Math.pow(this.y - coord2.y, 2)\n    );\n  }\n\n  angleBetween(coord2) {\n    return Math.atan2(coord2.y - this.y, coord2.x - this.x);\n  }\n\n  addVectorDiffs(speed, angle) {\n    const xDiff = Math.cos(angle) * speed;\n    const yDiff = Math.sin(angle) * speed;\n    return new Coord(this.x + xDiff, this.y + yDiff)\n  }\n\n  linePointNearest(lineStart, lineEnd) {\n    // BUG edge case of when the mouse point (this) is on line formed by\n    // lineStart => lineEnd;\n\n    const lerp = (a,b,x) => ( a +  (x * (b - a)));\n    const dx = lineEnd.x - lineStart.x;\n    const dy = lineEnd.y - lineStart.y;\n    // const slope = dy/dx;\n    // extrapolate line, check if point is on line , if so return\n    const t = ((this.x-lineStart.x) * dx + (this.y - lineStart.y) * dy)/( (dx * dx) + (dy * dy));\n\n    const lineX = lerp(lineStart.x, lineEnd.x, t);\n    const lineY = lerp(lineStart.y, lineEnd.y, t);\n\n    return new Coord(lineX, lineY);\n  }\n\n  scaleToScreen(height) {\n    const scaledX = this.x * (height / 1200);\n    const scaledY = this.y * (height / 1200);\n\n    this.x = scaledX;\n    this.y = scaledY;\n  }\n}\n\nexport default Coord;\n","import Map from \"./map\";\nimport MapView from \"./map_view\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  // TODO refactor for one controls evnt listener\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  const canvasContainerEl = document.getElementsByClassName(\"canvas-container\")[0];\n  const muteBtnEl = document.getElementsByClassName(\"mute\")[0];\n  const trainCtrlEl = document.getElementsByClassName(\"train-controls\")[0];\n  const resetBtnEl = document.getElementsByClassName(\"reset\")[0];\n  const backgroundImageEl = document.getElementsByClassName(\"background-img-container\")[0];\n  const subwayBulletEl = document.getElementsByClassName(\"bullet-hidden\")[0];\n\n  const width = canvasContainerEl.clientHeight * .9;\n  const height = canvasContainerEl.clientHeight * .9;\n  canvasEl.width = width;\n  canvasEl.height = height;\n  backgroundImageEl.style.cssText = `height: ${height}`;\n\n  window.AudioContext = window.AudioContext || window.webkitAudioContext;\n  const audioCtx = new AudioContext();\n\n  const ctx = canvasEl.getContext(\"2d\");\n  ctx.translate(0.5, 0.5);\n  ctx.lineCap = \"round\";\n\n  const map = new Map(width, height, audioCtx);\n\n  // canvasEl.addEventListener('mousemove', (e) => map.handleMouseMove(e))\n  canvasEl.addEventListener('click', e => map.handleClick(e));\n  resetBtnEl.addEventListener('click', e => map.resetMap(e));\n  trainCtrlEl.addEventListener('click', e => {\n    const dir = parseInt(e.target.dataset.dir);\n    map.startPaths(dir);\n  })\n\n  const mapView = new MapView(map, ctx, audioCtx);\n  muteBtnEl.addEventListener('click', e => mapView.toggleCtxMute(muteBtnEl));\n  document.addEventListener('keypress', e => mapView.handleKey(e, subwayBulletEl));\n  mapView.start();\n});\n","import Coord from './coord';\nimport Train from './train.js';\nimport bgMap from '../background_map/mapV2.json';\nimport TrainPath from './path';\nimport TrainPathSegment from './path_segment';\nimport TRAIN_DATA from '../subway_data_cleaned.json';\n\nconst BG_COLOR = '#282828';\nlet MAP_DATA = Object.values(TRAIN_DATA)\n\n// e only has one point, so no segments\n// '9' train is grand central shuttle\n// 3 only has one stop listed\nMAP_DATA = MAP_DATA.filter( line => !(line.lineName === 'STATEN'));\n\nconst sounds = [\n  261.63,\n  293.66,\n  329.63,\n  392.00,\n  440.00,\n  523.25,\n  587.33,\n  659.25,\n  783.99,\n  880.00,\n  1046.50,\n  1174.66,\n  1318.51,\n  1567.98,\n  1760.00,\n  2093.00,\n  2349.32,\n  2637.02,\n  130.81,\n  146.83,\n  164.81,\n  196.00,\n  220.00\n]\n//  C   D   E   G    A\n\nclass Map {\n  constructor(width, height, audioCtx) {\n    this.paths = [];\n    this.segments = [];\n    this.cnvWidth = width;\n    this.cnvHeight = height;\n    this.audioCtx = audioCtx;\n    this.setupMap();\n  }\n\n  startPaths(dir) {\n    this.paths.forEach( path => path.startPath(dir));\n  }\n\n  setupMap() {\n    for (let i = 0; i < MAP_DATA.length; i++) {\n      const path = new TrainPath(MAP_DATA[i], this);\n      this.paths.push(path);\n      this.addSegments(path, MAP_DATA[i].vertices, i);\n    }\n  }\n\n  resetMap() {\n    this.paths = [];\n    this.segments = [];\n    this.setupMap();\n  }\n\n  handleKey(e) {\n    e.preventDefault();\n\n    for (let i = 0; i < this.paths.length; i++) {\n      const key = e.key.toUpperCase();\n      if (this.paths[i].lineName === key && e.shiftKey) {\n        this.paths[i].startPath(-1)\n      } else if (this.paths[i].lineName === key) {\n        this.paths[i].startPath(1)\n      }\n    }\n  }\n\n  // handleMouseMove(e) {\n  //   e.stopPropagation();\n  //   const mousePos = new Coord(parseInt(e.offsetX), parseInt(e.offsetY));\n  //   this.paths.forEach(path => path.checkHovered(mousePos));\n  // }\n\n  handleClick(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    const mousePos = new Coord(parseInt(e.offsetX), parseInt(e.offsetY));\n    this.paths.forEach(path => path.checkClicked(mousePos));\n  }\n\n  togglePathsMute() {\n    this.muteDeselectedPaths();\n  }\n\n  muteDeselectedPaths() {\n    for(let i = 0; i < this.paths.length; i++) {\n      if (this.paths[i].selected) { continue }\n      this.paths[i].muted = true;\n    }\n  }\n\n  addSegments(path, vertices, i) {\n    for (let j = 0; j < vertices.length - 1; j++) {\n      const startPoint = new Coord(vertices[j][1][0], vertices[j][1][1]);\n      const endPoint = new Coord(vertices[j + 1][1][0], vertices[j + 1][1][1]);\n\n      startPoint.scaleToScreen(this.cnvHeight);\n      endPoint.scaleToScreen(this.cnvHeight);\n\n      const segment = new TrainPathSegment(path, startPoint, endPoint, j, sounds[i], this.audioCtx);\n      this.segments.push(segment);\n      path.segments.push(segment);\n    }\n  }\n\n  draw(ctx) {\n    ctx.clearRect(0, 0, this.cnvWidth, this.cnvHeight);\n    // ctx.fillStyle = BG_COLOR;\n    // ctx.fillRect(0, 0, this.cnvWidth, this.cnvHeight);\n    // this.drawBgMap(ctx);\n    const traceColor = '#52565c';\n    const traceWidth = 3;\n    const selectedWidth = 10;\n\n\n    this.segments.forEach(segment => {\n      const path = segment.parentPath;\n      path.lineWidth = (path.selected) ?\n        selectedWidth : traceWidth;\n\n      if (!segment.shouldBeDrawn) {\n        segment.drawTrace(ctx, traceColor, traceWidth);\n      } else {\n        return null;\n      }\n    });\n\n    this.segments.forEach(segment => {\n      const path = segment.parentPath;\n      path.lineWidth = (path.selected) ?\n        selectedWidth : traceWidth;\n\n      if (segment.shouldBeDrawn) {\n        (path.muted) ?\n          segment.draw(ctx, '#ffffff', traceColor, traceWidth) :\n          segment.draw(ctx, path.color, traceColor, traceWidth);\n      }\n    });\n\n    this.paths.forEach((path) => path.draw(ctx) );\n  }\n\n  drawBgMap(ctx) {\n    bgMap.forEach( vertices => {\n      ctx.fillStyle = '#000';\n      ctx.beginPath();\n      const first = new Coord(vertices[0][0], vertices[0][1]);\n      first.scaleToScreen(this.cnvHeight);\n      ctx.moveTo(first.x, first.y);\n\n      vertices.forEach( vertice => {\n        const bgMapCoord = new Coord( vertice[0], vertice[1]);\n        bgMapCoord.scaleToScreen(this.cnvHeight);\n        ctx.lineTo(bgMapCoord.x, bgMapCoord.y)\n      });\n      ctx.closePath();\n      ctx.fill();\n    });\n  }\n\n  step(delta) {\n    this.paths.forEach(path => path.moveTrains(delta));\n  }\n}\n\nexport default Map;\n\n// this.segments.forEach(segment => {\n//   const path = segment.parentPath;\n//   path.lineWidth = (path.selected) ?\n//     selectedWidth : traceWidth;\n//\n//   if (path.muted) {\n//     (segment.shouldBeDrawn) ?\n//       segment.draw(ctx, '#ffffff', traceColor, traceWidth) :\n//       segment.drawTrace(ctx, traceColor, traceWidth);\n//   }\n//   else if (segment.shouldBeDrawn) {\n//     segment.draw(ctx, path.color, traceColor, traceWidth);\n//   } else {\n//     segment.drawTrace(ctx, traceColor, traceWidth);\n//   };\n// });\n","class MapView {\n  constructor(map, ctx, audioCtx) {\n    this.map = map;\n    this.ctx = ctx;\n    this.audioCtx = audioCtx;\n  }\n\n  toggleCtxMute(muteBtnEl) {\n    if (this.audioCtx.state === 'suspended') {\n      this.audioCtx.resume().then( () => {\n        muteBtnEl.children[0].classList.toggle(\"fa-volume-up\");\n      });\n    } else if (this.audioCtx.state === 'running') {\n      this.audioCtx.suspend().then( () => {\n        muteBtnEl.children[0].classList.toggle(\"fa-volume-off\");\n      })\n    }\n  }\n\n  handleKey(e, subwayBulletEl) {\n    this.map.handleKey(e);\n    const key = e.key.toUpperCase()\n    subwayBulletEl.src = `/Users/cameronmcinnes/Documents/aA/projects/js_project/assets/subway_bullets/${key}.svg`;\n    if (subwayBulletEl.classList.contains('subway-bullet')) {\n      // BUG QUESTION waits for a second before going\n      subwayBulletEl.classList.remove('subway-bullet');\n      setTimeout( () => subwayBulletEl.classList.toggle('subway-bullet'), 10)\n    } else {\n      subwayBulletEl.classList.toggle('subway-bullet', true);\n    }\n  }\n\n  start() {\n    this.lastTime = 0;\n    // start the animation\n    requestAnimationFrame(this.animate.bind(this));\n  }\n\n  animate(time) {\n    const timeDelta = time - this.lastTime;\n\n    this.map.step(timeDelta);\n    this.map.draw(this.ctx);\n    this.lastTime = time;\n\n    // every call to animate requests causes another call to animate\n    requestAnimationFrame(this.animate.bind(this));\n  }\n}\n\nexport default MapView;\n","const dogBarkingBuffer = null;\n\n//\n// const loadDogSound = (audioCtx, url) => {\n//   const request = new XMLHttpRequest();\n//   request.open('GET', url, true);\n//   request.responseType = 'arraybuffer';\n//\n//   request.onload = function() {\n//     audioCtx.decodeAudioData(request.response, function(buffer) {\n//       dogBarkingBuffer = buffer;\n//     }, onError);\n//   }\n//   request.send();\n// }\n//\n// const playSound = (audioCtx, buffer) => {\n//   // creates a sound source\n//   var source = audioCtx.createBufferSource();\n//   // tell the source which sound to play\n//   source.buffer = buffer;\n//   // connect the source to the audioCtx's destination (the speakers)\n//   source.connect(audioCtx.destination);\n//   // play the source now\n//   source.start(0);\n// }\n\n//\nclass OscillatorSound {\n  constructor(audioCtx) {\n    this.audioCtx = audioCtx\n  }\n\n  setup() {\n    this.oscillator = this.audioCtx.createOscillator();\n    this.gainNode = this.audioCtx.createGain();\n\n    this.oscillator.connect(this.gainNode);\n    this.gainNode.connect(this.audioCtx.destination);\n    this.oscillator.type = 'sine';\n  }\n\n  play(freqValue) {\n    // have to stop playing sounds when audio ctx muted otherwise\n    // sounds queue and then play all at once on resume\n    if (this.audioCtx.state === 'suspended') { return null }\n    this.setup();\n\n    this.oscillator.frequency.setValueAtTime(freqValue, this.audioCtx.currentTime);\n    this.gainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);\n    this.gainNode.gain.linearRampToValueAtTime(\n      1,\n      this.audioCtx.currentTime + 0.01\n    );\n\n    this.oscillator.start(this.audioCtx.currentTime);\n    this.stop(this.audioCtx.currentTime);\n  }\n\n  stop() {\n    if (this.audioCtx.state === 'suspended') { return null }\n    \n    this.gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + 1);\n    this.oscillator.stop(this.audioCtx.currentTime + 1);\n  }\n}\n\nexport default OscillatorSound;\n","import Train from './train';\n\nclass Path {\n  constructor(options, map) {\n    this.lineName = options.lineName;\n    this.vertices = options.vertices;\n    this.color = options.color;\n    this.map = map;\n    this.segments = [];\n    this.durationMins = options.duration;\n    this.totalLength = 0;\n    this.muted = false;\n    this.selected = false;\n    this.lineWidth = 3;\n    this.fwdTrainsQueue = [];\n    this.bwdTrainsQueue = [];\n  }\n\n  getSpeed() {\n    return this.totalLength / (this.durationMins * 60)\n  }\n\n  // checkHovered(mousePos) {\n  //   this.segments.forEach( segment => segment.checkHovered(mousePos));\n  // }\n\n  checkClicked(mousePos) {\n    this.segments.forEach( segment => segment.checkClicked(mousePos));\n  }\n\n  addTrain(dir) {\n    let originSegment;\n    let initialTrainPos;\n    let storageQueue;\n\n    if (dir > 0) {\n      storageQueue = this.fwdTrainsQueue;\n      originSegment = this.segments[0];\n      initialTrainPos = originSegment.startPos;\n    } else if (dir < 0) {\n      storageQueue = this.bwdTrainsQueue;\n      originSegment = this.segments[this.segments.length - 1];\n      initialTrainPos = originSegment.endPos;\n    }\n\n    const train = new Train(this, dir, initialTrainPos, originSegment);\n    storageQueue.unshift(train);\n    originSegment.shouldBeDrawn = true;\n    originSegment.receiveTrain(train);\n  }\n\n  startPath(dir) {\n    this.addTrain(dir);\n  }\n\n  moveTrains(delta) {\n    this.bwdTrainsQueue.forEach(train => train.move(delta));\n    this.fwdTrainsQueue.forEach(train => train.move(delta));\n  }\n\n  restartPath() {\n    this.segments.forEach(segment => segment.shouldBeDrawn = false);\n    this.addTrain();\n  }\n\n  draw(ctx) {\n    // const traceColor = '#52565c';\n    // const traceWidth = 3;\n    // const selectedWidth = 10;\n    //\n    // this.lineWidth = (this.selected) ? selectedWidth : traceWidth;\n    // this.segments.forEach(segment => {\n    //   if (this.muted) {\n    //     (segment.shouldBeDrawn) ?\n    //       segment.draw(ctx, '#ffffff', traceColor, traceWidth) :\n    //       segment.drawTrace(ctx, traceColor, traceWidth);\n    //   }\n    //   else if (segment.shouldBeDrawn) {\n    //     segment.draw(ctx, this.color, traceColor, traceWidth);\n    //   } else {\n    //     segment.drawTrace(ctx, traceColor, traceWidth);\n    //   };\n    // });\n\n    this.drawTrains(ctx)\n  }\n\n  drawTrains(ctx) {\n    this.bwdTrainsQueue.forEach(train => train.draw(ctx));\n    this.fwdTrainsQueue.forEach(train => train.draw(ctx));\n  }\n\n  remove() {\n    this.map.remove(this);\n  }\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nexport default Path;\n","import OscillatorSound from './oscillator_sound';\n\nclass PathSegment {\n  constructor(path, startPos, endPos, j, frequency, audioCtx) {\n    this.parentPath = path;\n    this.startPos = startPos;\n    this.endPos = endPos;\n\n    this.trainOrigin\n    this.trainDestination\n    // angle of the thread from x axis toward y\n    this.angle = startPos.angleBetween(endPos);\n    this.backwardsAngle = endPos.angleBetween(startPos);\n\n    this.pos\n    // for debugging; index in its parent paths array of segments\n    this.ord = j;\n    // length from start to end pos\n    this.totalLength = startPos.distBetween(endPos);\n    // add segment length to parent path total length\n    this.parentPath.totalLength += this.totalLength;\n    // initialize threads w length 0, as train moves will increase length\n    this.length = 1;\n    // initialize without a train\n    this.train = null;\n\n    // segments start out traced\n    this.shouldBeDrawn = false;\n    this.frequency = frequency;\n    this.audioCtx = audioCtx;\n  }\n\n  receiveTrain(train) {\n    this.train = train;\n    this.shouldBeDrawn = true;\n\n    this.trainOrigin = (this.train.dir > 0) ?\n      this.startPos : this.endPos;\n\n    this.trainDestination = (this.train.dir > 0) ?\n      this.endPos : this.startPos;\n\n    this.pos = train.pos;\n  }\n\n  playSound() {\n    if (this.parentPath.muted) { return null }\n    let oscSound = new OscillatorSound(this.audioCtx);\n    oscSound.play(this.frequency);\n    oscSound.stop();\n  }\n\n  // need debouncing to make this work ???\n  // checkHovered(mousePos) {\n  //   // get the line point nearest to the mouse position with helper method;\n  //   const linePoint = mousePos.linePointNearest(this.startPos, this.pos);\n  //   if (linePoint.distBetween(mousePos) < this.parentPath.lineWidth * 2) {\n  //     debugger;\n  //     this.parentPath.selected = true;\n  //     this.parentPath.lineWidth = 10;\n  //   } else {\n  //     this.parentPath.selected = false;\n  //     // this.lineWidth = 3;\n  //   }\n  // }\n\n  checkClicked(mousePos) {\n    // get the line point nearest to the mouse position with helper method;\n    const linePoint = mousePos.linePointNearest(this.startPos, this.endPos);\n    // hacky to see if line point is on line\n    if (((this.startPos.x > linePoint.x && linePoint.x > this.endPos.x) || (this.startPos.x < linePoint.x && linePoint.x < this.endPos.x)) &&\n        ((this.startPos.y > linePoint.y && linePoint.y > this.endPos.y) || (this.startPos.y < linePoint.y && linePoint.y < this.endPos.y))) {\n      if (linePoint.distBetween(mousePos) < 5) {\n        this.toggleSelected();\n        this.parentPath.muted = false;\n        this.parentPath.map.togglePathsMute();\n      }\n    }\n  }\n\n  toggleSelected() {\n    this.parentPath.selected = !(this.parentPath.selected);\n  }\n\n  trainAdvanced(train) {\n    this.pos = train.pos;\n  }\n\n  releaseTrain() {\n    this.train = null;\n    // TODO\n    // trains\n    // this.shouldBeDrawn = false;\n    // to fade out from back\n    // this.fading = true;\n    // then in draw decrement the length of the fade pos at the same speed\n    // once it his a stoop\n\n  \tthis.pos = this.trainDestination;\n    // TEST\n    // if (this.ord === this.parentPath.segments.length - 1) {\n    //   this.parentPath.restartPath();\n    // }\n    this.playSound();\n  }\n\n  draw(ctx, color, traceColor, traceWidth) {\n    // draw from prev station to active train\n    // WHEN THERE ARE MULTIPLE TRAINS ON A SEGMENT;\n    ctx.beginPath();\n    ctx.moveTo(this.trainOrigin.x, this.trainOrigin.y);\n    ctx.lineTo(this.pos.x, this.pos.y);\n    ctx.strokeStyle = color;\n    ctx.lineWidth = this.parentPath.lineWidth;\n    ctx.stroke();\n\n    // draw trace from train to next station\n    ctx.beginPath();\n    ctx.moveTo(this.pos.x, this.pos.y);\n    ctx.lineTo(this.trainDestination.x, this.trainDestination.y);\n    ctx.strokeStyle = traceColor;\n    ctx.lineWidth = traceWidth;\n    ctx.stroke();\n\n\n    this.drawStation(ctx);\n  }\n\n  drawStation(ctx) {\n    ctx.beginPath();\n    ctx.fillStyle = '#ffffff';\n    ctx.arc(this.trainOrigin.x, this.trainOrigin.y, 2, 0, Math.PI*2, false);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  drawTrace(ctx, color, width) {\n    ctx.beginPath();\n    ctx.moveTo(this.startPos.x, this.startPos.y);\n    ctx.lineTo(this.endPos.x, this.endPos.y);\n    ctx.strokeStyle = color;\n    ctx.lineWidth = width;\n    ctx.stroke();\n  }\n}\n\nexport default PathSegment;\n","import { shadeHexColor } from './color_helper';\n\nclass TrainCar {\n  constructor(path, dir, initialTrainPos, originSegment) {\n    this.parentPath = path;\n    this.speed = this.parentPath.getSpeed();\n\n    this.dir = dir;\n\n    this.currSegment = originSegment;\n\n    this.pos = initialTrainPos\n\n    this.isMoving = true;\n\n    this.pulsing = false;\n    // to start pulsing fast then slow\n    this.pulseDampen = .5\n    this.pulseAngle = 0;\n  }\n\n  draw(ctx) {\n    const color = (this.parentPath.muted) ? '#fff' : this.parentPath.color;\n    // BUG\n    const lighter = shadeHexColor(color, 20);\n\n    let rad = 4\n    let baseRad = 3\n    if (this.parentPath.selected) { rad = 7; baseRad = 6 }\n    if (this.pulsing) {\n      rad = baseRad + 2 * Math.abs(Math.cos(this.pulseAngle));\n      this.pulseAngle += (Math.PI / 12 * this.pulseDampen);\n\n      ctx.beginPath();\n      ctx.fillStyle = '#fff';\n      ctx.arc(this.pos.x, this.pos.y, rad + 1, 0, Math.PI*2, false);\n      ctx.closePath();\n      ctx.fill();\n      // once train has shrunk down to size it was stop pulsing and\n      // reset pulse angle to 0 so it will grow next time again\n      if (rad < baseRad + 1) {this.pulsing = false; this.pulseAngle = 0};\n    }\n    ctx.beginPath();\n    ctx.fillStyle = color;\n    ctx.arc(this.pos.x, this.pos.y, rad, 0, Math.PI*2, false);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  move(timeDelta) {\n    // TODO refactor into helper methods, move forward move back\n\n    const { trainOrigin, angle, backwardsAngle, totalLength, ord } = this.currSegment;\n    const speedScale = timeDelta / NORMAL_FRAME_TIME_DELTA\n    const speed = this.speed * speedScale;\n\n    const trainAngle = (this.dir > 0) ? angle : backwardsAngle;\n\n    this.pos = this.pos.addVectorDiffs(speed, trainAngle);\n    const trainTravelDist = trainOrigin.distBetween(this.pos);\n    if ( trainTravelDist > totalLength ) {\n      this.currSegment.releaseTrain();\n      // reset the trains current seg to next seg\n      // add train to next seg\n      const nextOrd = (this.dir > 0) ? ord + 1 : ord - 1\n      const nextSegment = this.parentPath.segments[nextOrd]\n\n      if (nextSegment) {\n        this.currSegment = nextSegment;\n        nextSegment.receiveTrain(this);\n        this.pulsing = true;\n      } else {\n        this.removeSelf();\n      }\n    } else {\n      this.currSegment.trainAdvanced(this);\n    }\n  }\n\n  removeSelf() {\n    if (this.dir > 0) {\n      this.parentPath.fwdTrainsQueue.pop();\n    } else if (this.dir < 0) {\n      this.parentPath.bwdTrainsQueue.pop();\n    }\n  }\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nexport default TrainCar;\n"],"sourceRoot":""}