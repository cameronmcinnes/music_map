{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/coord.js","webpack:///./lib/entry.js","webpack:///./lib/map.js","webpack:///./lib/map_view.js","webpack:///./lib/path.js","webpack:///./lib/path_segment.js","webpack:///./lib/sound_util.js","webpack:///./lib/train.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;ACnEA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;AC/BA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;;;;;ACpBD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,2BAA2B;AAC3B,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;;AC5GA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACxBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;ACnDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjEA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9DA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,4CAA4C;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/entry.js\");\n","class Coord {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  equals(coord2) {\n    return (this.x == coord2.x) && (this.y == coord2.y);\n  }\n\n  plus(coord2) {\n    return new Coord(this.x + coord2.x, this.y + coord2.y);\n  }\n\n  distBetween(coord2) {\n    return Math.sqrt(\n      Math.pow(this.x - coord2.x, 2) + Math.pow(this.y - coord2.y, 2)\n    );\n  }\n\n  angleBetween(coord2) {\n    return Math.atan2(coord2.y - this.y, coord2.x - this.x);\n  }\n\n  addVectorDiffs(speed, angle) {\n    const xDiff = Math.cos(angle) * speed;\n    const yDiff = Math.sin(angle) * speed;\n    return new Coord(this.x + xDiff, this.y + yDiff)\n  }\n}\n\nexport default Coord;\n","import Map from \"./map\";\nimport MapView from \"./map_view\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  // use canvasEl.clientHeight and canvasEl.clientWidth but then have\n  // to make data point relative\n  const width = 1200;\n  const height = 1200;\n  canvasEl.width = width;\n  canvasEl.height = height;\n\n  window.AudioContext = window.AudioContext || window.webkitAudioContext;\n  const audioCtx = new AudioContext();\n\n  const ctx = canvasEl.getContext(\"2d\");\n  ctx.lineCap = \"round\";\n\n  const map = new Map(width, height, audioCtx);\n  new MapView(map, ctx).start();\n});\n","import Coord from './coord';\nimport Train from './train.js';\nimport TrainPath from './path';\nimport TrainPathSegment from './path_segment';\nimport TRAIN_DATA from '../subway_data.json';\n\nconst BG_COLOR = '#000000';\nlet MAP_DATA = Object.values(TRAIN_DATA)\nMAP_DATA = MAP_DATA.filter( line => {\n    return !(line.lineName === 'E' ||\n    line.lineName === '9' ||\n    line.lineName === 'S' ||\n    line.lineName === '3')\n  }\n);\n\nconst sounds = [\n  130.81,\n  146.83,\n  164.81,\n  196.00,\n  220.00,\n  261.63,\n  293.66,\n  329.63,\n  392.00,\n  440.00,\n  523.25,\n  587.33,\n  659.25,\n  783.99,\n  880.00,\n  1046.50,\n  1174.66,\n  1318.51\n]\n//  C   D   E   G    A\n\nclass Map {\n  constructor(width, height, audioCtx) {\n    this.paths = [];\n    this.trains = [];\n    this.cnvWidth = width;\n    this.cnvHeight = height;\n    this.audioCtx = audioCtx;\n    this.setupMap();\n    this.startPaths();\n  }\n\n  startPaths() {\n    this.paths.forEach( path => path.startPath());\n  }\n\n  setupMap() {\n    // debugger;\n    for (let i = 0; i < MAP_DATA.length; i++) {\n      // e only has one point, so no segments\n      // '9' train is grand central shuttle\n      // 3 only has one stop listed\n      // if (MAP_DATA[i].lineName === 'E' ||\n      //   MAP_DATA[i].lineName === '9' ||\n      //   MAP_DATA[i].lineName === 'S' ||\n      //   MAP_DATA[i].lineName === '3') { continue };\n\n      const path = new TrainPath(MAP_DATA[i], this);\n      this.paths.push(path);\n      this.addSegments(path, MAP_DATA[i].vertices, i);\n    }\n  }\n\n  addSegments(path, vertices, i) {\n    for (let j = 0; j < vertices.length - 1; j++) {\n      const startPoint = new Coord(vertices[j][0], vertices[j][1]);\n      const endPoint = new Coord(vertices[j + 1][0], vertices[j + 1][1]);\n\n      const segment = new TrainPathSegment(path, startPoint, endPoint, j, sounds[i], this.audioCtx);\n      path.segments.push(segment);\n    }\n  }\n\n  draw(ctx) {\n    ctx.clearRect(0, 0, this.cnvWidth, this.cnvHeight);\n    // ctx.fillStyle = BG_COLOR;\n    // ctx.fillRect(0, 0, this.cnvWidth, this.cnvHeight);\n\n    // forEach or for loop?\n    this.paths.forEach((path) => {\n      path.draw(ctx);\n    });\n\n    this.trains.forEach(train => {\n      if (train.isMoving) {train.draw(ctx)};\n    })\n  }\n\n  moveTrains(delta) {\n    this.trains.forEach((train) => {\n      if (train.isMoving) train.move(delta);\n    });\n  }\n\n  step(delta) {\n    this.moveTrains(delta);\n    // this.checkIntersections();\n  }\n}\n\n\nexport default Map;\n","class MapView {\n  constructor(map, ctx) {\n    this.ctx = ctx;\n    this.map = map;\n  }\n\n  start() {\n    this.lastTime = 0;\n    // start the animation\n    requestAnimationFrame(this.animate.bind(this));\n  }\n\n  animate(time) {\n    const timeDelta = time - this.lastTime;\n\n    this.map.step(timeDelta);\n    this.map.draw(this.ctx);\n    this.lastTime = time;\n\n    // every call to animate requests causes another call to animate\n    requestAnimationFrame(this.animate.bind(this));\n  }\n}\n\nexport default MapView;\n","import Train from './train';\n\nclass Path {\n  constructor(options, map) {\n    this.startPos = options.startPos;\n    this.lineName = options.lineName;\n    // this.endPos = options.endPos;\n    this.vertices = options.vertices;\n    // this.vel = options.vel;\n    this.color = options.color;\n    this.map = map;\n    this.segments = [];\n    this.durationMins = options.duration;\n    this.totalLength = 0;\n  }\n\n  getSpeed() {\n    return this.totalLength / (this.durationMins * 60)\n  }\n\n  addTrain() {\n    const train = new Train(this);\n    this.map.trains.push(train);\n    const firstSegment = this.segments[0];\n\n    firstSegment.shouldBeDrawn = true;\n    firstSegment.receiveTrain(train);\n  }\n\n  startPath() {\n    this.addTrain();\n  }\n\n  restartPath() {\n    this.segments.forEach(segment => segment.shouldBeDrawn = false);\n    this.addTrain();\n  }\n\n  draw(ctx) {\n    this.segments.forEach(segment => {\n      if (segment.shouldBeDrawn) segment.draw(ctx);\n    });\n  }\n\n  remove() {\n    this.map.remove(this);\n  }\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nexport default Path;\n","import OscillatorSound from './sound_util';\n\nclass PathSegment {\n  constructor(path, startPos, endPos, j, frequency, audioCtx) {\n    this.parentPath = path;\n    // the start and end of the segment on the fully drawn map\n    this.startPos = startPos;\n    this.endPos = endPos;\n    // angle of the thread from x axis toward y\n    this.angle = startPos.angleBetween(endPos);\n    // will\n    this.pos = startPos;\n    // index in its parent paths array of segments\n    this.ord = j;\n    // length from start to end pos\n    this.totalLength = startPos.distBetween(endPos);\n    // add segment length to parent path total length\n    this.parentPath.totalLength += this.totalLength;\n    // initialize threads w length 0, as train moves will increase length\n    this.length = 1;\n    // initialize without a train\n    this.train = null;\n    // segments start out invisible\n    this.shouldBeDrawn = false;\n    this.frequency = frequency\n    this.audioCtx = audioCtx\n  }\n\n  receiveTrain(train) {\n    this.train = train;\n    this.shouldBeDrawn = true;\n    this.pos = train.pos;\n    // set timeout?\n  }\n\n  playSound() {\n    let oscSound = new OscillatorSound(this.audioCtx);\n    oscSound.play(this.frequency);\n    oscSound.stop();\n  }\n\n  trainAdvanced(train) {\n    this.pos = train.pos;\n  }\n\n  releaseTrain() {\n    this.train = null;\n  \t// finished traveling segment, set position to the original end point\n  \tthis.pos = this.endPos;\n    if (this.ord === this.parentPath.segments.length - 1) {\n      this.parentPath.restartPath();\n    }\n    this.playSound();\n  }\n\n  draw(ctx) {\n    ctx.beginPath();\n    ctx.moveTo(this.startPos.x, this.startPos.y);\n    ctx.lineTo(this.pos.x, this.pos.y);\n    ctx.strokeStyle = this.parentPath.color;\n    ctx.lineWidth = 3;\n    ctx.stroke();\n  }\n}\n\nexport default PathSegment;\n","const dogBarkingBuffer = null;\n\n//\n// const loadDogSound = (audioCtx, url) => {\n//   const request = new XMLHttpRequest();\n//   request.open('GET', url, true);\n//   request.responseType = 'arraybuffer';\n//\n//   request.onload = function() {\n//     audioCtx.decodeAudioData(request.response, function(buffer) {\n//       dogBarkingBuffer = buffer;\n//     }, onError);\n//   }\n//   request.send();\n// }\n//\n// const playSound = (audioCtx, buffer) => {\n//   // creates a sound source\n//   var source = audioCtx.createBufferSource();\n//   // tell the source which sound to play\n//   source.buffer = buffer;\n//   // connect the source to the audioCtx's destination (the speakers)\n//   source.connect(audioCtx.destination);\n//   // play the source now\n//   source.start(0);\n// }\n\n//\nclass OscillatorSound {\n  constructor(audioCtx) {\n    this.audioCtx = audioCtx\n  }\n\n  setup() {\n    this.oscillator = this.audioCtx.createOscillator();\n    this.gainNode = this.audioCtx.createGain();\n\n    this.oscillator.connect(this.gainNode);\n    this.gainNode.connect(this.audioCtx.destination);\n    this.oscillator.type = 'sine';\n  }\n\n  play(freqValue) {\n    this.setup();\n    \n    this.oscillator.frequency.setValueAtTime(freqValue, this.audioCtx.currentTime);\n    this.gainNode.gain.setValueAtTime(0, this.audioCtx.currentTime);\n    this.gainNode.gain.linearRampToValueAtTime(\n      1,\n      this.audioCtx.currentTime + 0.01\n    );\n\n    this.oscillator.start(this.audioCtx.currentTime);\n    this.stop(this.audioCtx.currentTime);\n  }\n\n  stop() {\n    this.gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + 1);\n    this.oscillator.stop(this.audioCtx.currentTime + 1);\n  }\n}\n\nexport default OscillatorSound;\n","class TrainCar {\n  constructor(path) {\n    this.parentPath = path;\n    this.speed = this.parentPath.getSpeed();\n    this.color = this.parentPath.color;\n\n    this.currSegment = this.parentPath.segments[0];\n    this.pos = this.currSegment.startPos;\n    this.isMoving = true;\n\n    this.pulsing = false;\n    this.pulseDampen = .95;\n    this.pulseAngle = 0;\n  }\n\n  draw(ctx) {\n    ctx.beginPath();\n    ctx.fillStyle = this.color;\n    let rad = 4\n    if (this.pulsing) {\n      rad = 3 + 2 * Math.abs(Math.cos(this.pulseAngle));\n      this.pulseAngle += Math.PI / 128;\n      // once train has shrunk down to size it was stop pulsing and\n      // reset pulse angle to 0 so it will grow next time again\n      if (rad < 4) {this.pulsing = false; this.pulseAngle = 0};\n    }\n    ctx.arc(this.pos.x, this.pos.y, rad, 0, Math.PI*2, false);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  move(timeDelta) {\n    const { startPos, endPos, angle, totalLength, ord } = this.currSegment;\n    const speedScale = timeDelta / NORMAL_FRAME_TIME_DELTA\n    const speed = this.speed * speedScale;\n\n    this.pos = this.pos.addVectorDiffs(speed, angle);\n    const trainTravelDist = startPos.distBetween(this.pos);\n    if ( trainTravelDist > totalLength ) {\n      this.currSegment.releaseTrain();\n      // reset the trains current seg to next seg\n      // add train to next seg\n      const nextSegment = this.parentPath.segments[ord + 1]\n      if (nextSegment) {\n        this.currSegment = nextSegment;\n        nextSegment.receiveTrain(this);\n        this.pulsing = true;\n      } else {\n        // or would it be better to remove it from trains array to\n        // save on iterating?\n        this.isMoving = false;\n        return null;\n      }\n    } else {\n      this.currSegment.trainAdvanced(this);\n    }\n  }\n}\n\nconst NORMAL_FRAME_TIME_DELTA = 1000 / 60;\n\nexport default TrainCar;\n"],"sourceRoot":""}